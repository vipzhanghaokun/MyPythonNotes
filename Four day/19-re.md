# re - 正则表达式



## 一、正则表达式语法

​	正则表达式 （或 RE） 指定一组字符串匹配它；在此模块中的功能让您检查一下，如果一个特定的字符串匹配给定的正则表达式 。

​	多个正则表达式通过相连形成新的正则表达式; 如果*A* 和 *B* 两个都是正则表达式, 那么 *AB* 也是正则表达式。如果*A* 和 *B* 两个都是正则表达式, 那么 *AB* 也是正则表达式。一般来说，如果字符串*p*匹配*A*且另一个字符串*q*匹配*B*，那么字符串*pq*将匹配AB。除非*A*或者*B*包含的优先级较低; 或 *A*和*B*有边界条件;或者有被数组引用。

​	正则表达式可以包含特殊和普通字符。最普通的字符，如 `'A'`，`'a'`，或 `'0'`，是最简单的正则表达式;他们只是与自己相匹配。你可以连接普通的字符, 所以`last`匹配字符串`'last'`。

​	某些字符, 像 `'|'`或者`'('`是有特殊含义的。特殊字符要么表示某个类别的普通字符，要么影响它们周围的正则表达式如何解释。

### 特殊字符

* `'.'`

  （点号。）在默认模式下，匹配除换行符之外的任何字符。

* `'^'`

  （脱字符号。）从字符串的开始**匹配**

* `'$'`

  匹配字符串的结尾或只是之前换行符结尾的字符串，并在 [`多行`](http://python.usyiyi.cn/documents/python_352/library/re.html#re.MULTILINE) 模式下也匹配在换行符之前。

* `'*'`

  匹配前面重复出现的正则表达式零次或多次，尽可能多的匹配。`ab*`将匹配'a'，'ab'或'a'后跟任意数量的'b'。

* `'+'`

  匹配前面重复出现的正则表达式1次或多次，尽可能多的匹配。`ab+`将匹配'a'，后跟不少于一个的'b'；它将不匹配只是'a'。

* `'?'`

  引起生成的RE匹配0个或1个前导的RE。`ab?`将匹配'a'或'ab'。

* `*?`，`+?`，`??`

  `'*'`，`'+'`和`'?'`都是 *贪婪模式*它们尽可能匹配多次。有时我们不希望匹配多次；如果`<.*>`用来匹配 `<a> b <c>`, 它将会匹配所有字符串, 不只是`<a>`.加上`?`限定符将使得匹配为*非贪婪模式*或者*minimal*匹配； *few*尽可能少的字符被匹配。使用`<.*?>`将会仅匹配`<a>`.

* `{m}`

  精确的指定RE应该被匹配*m*次；少于m次将导致RE不会被匹配上。例如, `a{6}`将会精确匹配`'a'`字符6次，五次将不会被匹配。

* `{m,n}`

  引起生成的正则表达式匹配前导正则表达式的*m*到*n*个重复，尝试匹配尽可能多的重复。例如，`a{3,5}`将匹配3到5个`'a'`字符。省略*m*指定零的下限，省略*n*指定无限上限。例如，`a{4,}b`将匹配`aaaab`以及1千个`'a'`字符后面跟随一个`b`，但不能匹配`aaab`。逗号不可以省略，否则该修改符将与前面的形式混淆。

* `{m,n}?`

  例如，对于6个字符的字符串`'aaaaaa'`，`a{3,5}`将匹配5个`'a'`字符，而 `a{3,5}?`将只匹配3个字符。

* `'\'`

  消除特殊字符含义(允许匹配像`'*'`, `'?'`,等特殊字符), 或者发出特殊序列信号。

* `[]`

  用来表示一个字符集合。在这个集合中：

  - 字符可以被单独罗列，例如：`[amk]` 会匹配 `'a'`, `'m'`, 或 `'k'`.
  - 字符范围可以表明通过给予两个字符和分离他们的 `'-'`、 例如 `[z]` 将匹配任何小写字母的 ASCII 字母、 `[0-5] [0-9]` 将匹配所有两位数数字从 `00`到 `59`，和 `[0-9A-Fa-f]` 将都匹配任何十六进制数字。如果`-`被转义（例如，`[a\-z]`），或者将其放置为第一个或最后一个字符（例如，`[a-]`），它将匹配字面值`'-'`。
  - 在集合内，特殊字符失去特殊意义。例如，`[(+*)]` 将匹配任何字符 `'('`，`'+'`，`'* '`，或 `'')''`。
  - 如`\w` or `\S`等字符类别也是可以被接受的（译者注:不会失去特殊意义），尽管匹配的这些字符取决于`ASCII`or `LOCALE` 模式是否被设置。
  - 不在一段范围之内的字符可以通过*补集*匹配。如果这个集合的第一个字符是`'^'`, 那么所有*不*在集合内的将会被匹配上。例如, `[^5]`将会配对除`'5'`以外的任何字符，并且和`[^^]`将会匹配除`'^'`以外的任何字符。如果`^`不在集合的第一个位置那么它将没有特殊意义。
  - 想要在一个集合内匹配`']'`，需要在它的前面使用一个反斜杠转义，或者在集合开头处将它替换。例如， `[()[\]{}]` and `[]()[{}]` 都将会匹配一对括号。

* `'|'`

  `A|B`，其中A和B可以是任意RE，创建将匹配A或B的正则表达式。以这种方式，任意数量的RE可以由`'|'`分隔。这同样可以用在组里面。当扫描目标字符串时，从左到右尝试由`'|'`分隔的RE。当一个模式被完全匹配时，这个被匹配的模式就被接受。这意味着，一旦`A`匹配，则`B`将不会被进一步测试，即使它将产生更长的整体匹配。换句话说，`'|'`操作符从不贪婪。要匹配字面值`'|'`，请使用`\|`或将其包含在字符类中，如`[|]`。

* `(...)`

  匹配括号内的任何正则表达式，并指明组的开始和结束；可以在执行匹配之后检索组的内容，并且可以稍后在字符串中与`\number`特殊序列匹配，如下所述。匹配字面上的`'('` or `')'`, 使用 `\(` or `\)`, 或者把它们装入一个字符集中: `[(] [)]`.

* `(?P<name>...)`

  和正则括号相似, 但是这个组匹配到的子字符串可以通过符号组名称*name*进行访问.

* `\number`

  匹配相对应组编号的内容。组号从1开始。例如，`(.+) \1` 匹配 `'the the'`或者 `'55 55'`, 但是不会匹配`'thethe'` (注意在匹配上的组后有空格)。

* `\A`

  仅仅匹配字符串开头

* `\b`

  仅仅匹配单词的开头或结尾（译者注：不是字符串开头和结尾哦）。单词被定义为由Unicode字母数字或下划线组成的序列，因此单词的结尾由空格、非字母数字或非下划线Unicode字符表示。

* `\B`

  匹配一个单词*不*在开头或结尾的字符。

* `\d`

  - 对于Unicode（str）模式：

    匹配任何Unicode十进制数字（即，Unicode字符类别[Nd]中的任何字符）。这包括`[0-9]`以及许多其他数字字符。如果使用[`ASCII`](http://python.usyiyi.cn/documents/python_352/library/re.html#re.ASCII)标志只有`[0-9]`匹配（但该标志影响整个正则表达式，因此在这种情况下使用显式`[0-9]`可能是更好的选择）。

  - 对于8位（字节）模式：

    匹配任何十进制数字；这相当于`[0-9]`。

* `\D`

  匹配任何不是Unicode十进制数字的字符。这与`\d`相反。如果使用`ASCII`标志，这相当于`[^0-9]`（但标志影响整个正则表达式，因此在这种情况下使用显式`[^0-9]`可能是更好的选择）。

* `\s`

  - 对于Unicode（str）模式：

    匹配Unicode空格字符（其中包括`[ \ t \ n \ r \ f \ v]`，以及许多其他字符，例如在许多语言中由排版规则强制的不间断空间）。如果使用[`ASCII`](http://python.usyiyi.cn/documents/python_352/library/re.html#re.ASCII)标志，只有`[ \ t \ n \ r \ f \ v]` （但是该标志影响整个正则表达式，因此在这种情况下使用显式`[ \ t \ n \ r \ f \ v]`可能是更好的选择）。

  - 对于8位（字节）模式：

    匹配ASCII字符集中被视为空格的字符；这等同于`[ \ t \ n \ r \ f \ v]`。

* `\S`

  匹配任何不是Unicode空格字符的字符。这与`\s`相反。如果使用`ASCII`标志，这相当于`[^ \ t \ n \ r \ f \ v] t3>（但是该标志影响整个正则表达式，因此在这种情况下使用显式[^ \ t \ n \ r \ f \ v] / t6>可能是更好的选择）。`

* `\w`

  - 对于Unicode（str）模式：

    匹配Unicode字符；这包括可以作为任何语言中的单词的一部分的大多数字符，以及数字和下划线。如果使用[`ASCII`](http://python.usyiyi.cn/documents/python_352/library/re.html#re.ASCII)标志，只有`[a-zA-Z0-9_]`匹配（但是标志影响整个正则表达式， `[a-zA-Z0-9_]`可能是更好的选择）。

  - 对于8位（字节）模式：

    匹配ASCII字符集中被视为字母数字的字符；这相当于`[a-zA-Z0-9_]`。

* `\W`

  匹配任何不是Unicode字符的字符。这与`\w`相反。如果使用`ASCII`标志，这相当于`[^a-zA-Z0-9_]`（但标志影响整个正则表达式，因此在这种情况下使用显式的`[^a-zA-Z0-9_]`可能是更好的选择）。

* `\Z`

  只在字符串的结尾处进行匹配



## 二、模块内容

> ​	模块定义了几个函数、 常量和一个异常。某些函数是编译正则表达式全特性方法的简化版本。大多数复杂应用程序总是使用已编译的形式。

* `re.compile`(*pattern*, *flags=0*)

  将正则表达式模式编译成一个正则表达式对象，匹配时可以调用它的 [`match()`](http://python.usyiyi.cn/documents/python_352/library/re.html#re.regex.match) 和 [`search()`](http://python.usyiyi.cn/documents/python_352/library/re.html#re.regex.search) 方法，如下所述。

  可以通过指定*flags* 值修改表达式的行为。值可以是任何以下变量， 组合使用 OR ( `|` 运算符).

  序列

  ```
  prog = re.compile(pattern)
  result = prog.match(string)

  ```

  等同于

  ```
  result = re.match(pattern, string)

  ```

  但表达式在单个程序中多次使用时， 使用`re.compile()`和保存生成的正则表达式对象重用效率更高。

* `re.A`

  `re.ASCII`

  让`\w`，`\W`，`\b`，`\B`，`\d` ，`\D`，`\s`和`\S`执行纯ASCII匹配而不是完全Unicode匹配。这只对Unicode模式有意义，对于字节模式将被忽略。

* `re.DEBUG`

  显示调试信息编译的表达式。

* `re.I`

  `re.IGNORECASE`

  执行不区分大小写的匹配; 如 `[A-Z]`也将匹配为小写字母。

* `re.L`

  `re.LOCALE`

  让`\w`，`\W`，`\b`，`\B`，`\s`和`\S`，具体取决于当前语言环境。不鼓励使用此标志，

* `re.M`

  `re.MULTILINE`

  指定时，模式字符`'^'`在字符串开头和每行开头（紧跟每个换行符后）匹配；并且模式字符`'$'`在字符串的末尾和每行的末尾（紧接在每个换行符之前）匹配。默认情况下，`'^'`仅在字符串开头匹配，`'$'`仅在字符串结尾处，字符串的结尾。

* `re.S`

  `re.DOTALL`

  制作`'.'`特殊字符匹配任何字符，包括换行符；没有此标志，`'.'`将匹配除了换行符之外的任何*。*

* `re.X`

  `re.VERBOSE`

  此标志允许您编写正则表达式看起来更好，更可读，通过允许您在视觉上分离模式的逻辑节并添加注释。

  这意味着匹配十进制数的两个以下正则表达式对象在功能上是相等的：

  ```
  a = re.compile(r"""\d +  # the integral part
                     \.    # the decimal point
                     \d *  # some fractional digits""", re.X)
  b = re.compile(r"\d+\.\d*")
  ```

* `re.search(pattern, string, flags=0)`

  扫描*字符串*查找正则表达式*模式*产生匹配的第一个位置，并返回相应的match object。如果字符串中没有位置与模式匹配，则返回`None`；请注意，这不同于在字符串中的某个点找到零长度匹配。

* `re.match(*pattern*, *string*, *flags=0*)`

  如果*字符串*开头的零个或多个字符与正则表达式*模式*相匹配，则返回相应的match object。如果字符串与模式不匹配，则返回`None`；

* `re.fullmatch(pattern, string, flags=0)`

  如果整个*字符串*与正则表达式*模式*相匹配，则返回相应的match object。如果字符串与模式不匹配，则返回`None`；

* `re.split(pattern, string, maxsplit=0, flags=0)`

  将*字符串*拆分的*模式*的匹配项。如果在*模式*中使用捕获括号，则然后也作为结果列表的一部分返回的文本模式中的所有组。如果*maxsplit*不为零，顶多*maxsplit*分裂发生，并且该字符串的其余部分将作为列表的最后一个元素返回。

  ```python
  >>> re.split('\W+', 'Words, words, words.')
  ['Words', 'words', 'words', '']
  >>> re.split('(\W+)', 'Words, words, words.')
  ['Words', ', ', 'words', ', ', 'words', '.', '']
  >>> re.split('\W+', 'Words, words, words.', 1)
  ['Words', 'words, words.']
  >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)
  ['0', '3', '9']
  ```

  ​

* `re.findall(pattern, string, flags=0)`

  作为一个字符串列表，在*字符串*中，返回所有非重叠匹配的*模式*。The *string*是从左到右扫描的，所以匹配的内容是按照该顺序来的如果模式中存在一个或多个组，请返回组列表；如果模式具有多个组，这将是元组的列表。

* `re.finditer(*pattern*, *string*, *flags=0*)`

  在*string*中为RE *模式*的所有非重叠匹配返回iterator产生match objects。该*字符串*是从左到右扫描的，匹配按照发现的顺序返回。空匹配包含在结果中，除非他们接触到另一场匹配的开头。

* `re.sub(*pattern*, *repl*, *string*, *count=0*, *flags=0*)`

  将*string*中最左侧非重叠出现的*pattern*替换为*repl*，返回所获得的字符串。如果pattern没有被找到， *string*不变。*repl* 可以是一个字符串或一个函数；如果是一个字符串, 则会处理每个反斜杠转义。

* `re.subn(*pattern*, *repl*, *string*, *count=0*, *flags=0*)`

  执行与`sub()`相同的操作，但返回一个元组`（new_string， number_of_subs_made）`。

* `re.escape(*string*)`

  退出模式中除ASCII字母，数字和`'_'`之外的所有字符。这是有用的如果你想匹配一个任意的文本字符串，在它可能包含正则表达式元字符。

* `re.purge()`

  清除正则表达式缓存。

* ​



## 三、正则表达式对象

已编译的正则表达式对象支持下列方法和属性︰

* `regex.search(*string*[, *pos*[, *endpos*]])`

  扫描*string* 寻找正则表达式产生匹配后的第一个位置 , 然后返回一个相对应的 match object.如果字符串中没有位置与模式匹配，则返回`None`

* `regex.match(*string*[, *pos*[, *endpos*]])`

  如果*字符串*的*开始*处的零个或多个字符与此正则表达式匹配，则返回相应的match object。

* `regex.fullmatch(*string*[, *pos*[, *endpos*]])`

  如果整个*字符串*与此正则表达式匹配，则返回相应的match object。如果字符串与模式不匹配，则返回`None`

* `regex.split(*string*, *maxsplit=0*)`

  与`split()`函数相同，使用编译的模式。

* `regex.findall(*string*[, *pos*[, *endpos*]])`

  类似于 `findall()`的功能，使用已编译的模版，但也接受可选的 *pos* 和 *endpos* 参数限制搜索区域像 `match （）`。

* `regex.finditer(*string*[, *pos*[, *endpos*]])`

  类似于 `finditer()`的功能，使用已编译的模版，但也接受可选的 *pos* 和 *endpos* 参数像 `match （）`限制搜索区域。

* `regex.sub(*repl*, *string*, *count=0*)`

  与`sub()`函数相同，使用编译的模式。

* `regex.subn(*repl*, *string*, *count=0*)`

  与`subn()`函数相同，使用编译的模式。

* `regex.flags`

  正则表达式匹配的标志。

* `regex.groups`

  捕获模式中的组数。

* `regex.pattern`

  模式字符串中从中重新对象的编译。



## 三、Match对象

> ​	Match对象总是有一个`True`的布尔值。由于`match()`和`search()`在没有匹配上时返回 `None`。你可以用简单的 `if`语句测试是否有match对象。
>
> ```python
> match = re.search(pattern, string)
> if match:
>     process(match)
> ```



Match 对象支持下列方法和属性︰

* `match.expand(*template*)`

  返回通过对模板字符串*模板*执行反斜杠替换获得的字符串，如`sub()`方法所做

* `match.group([*group1*, *...*])`

  返回Match对象的一个或多个子组。如果有一个参数，结果是单个字符串；如果有多个参数，结果是每个参数有一个项的元组。如果没有参数， *group1*默认为零 （整场比赛返回）。

* `match.groups`(*default=None*)`

  返回包含所有匹配到的子组的元组， 从1到模式中的所有组。*默认*参数用于未参与匹配的组；它默认为`None`。

  ```python
  >>> m = re.match(r"(\d+)\.(\d+)", "24.1632")
  >>> m.groups()
  ('24', '1632')
  ```

  ​

* `match.``groupdict`(*default=None*)

  返回一个有*别名*的组的匹配子组的字典（没有别名的子组不包含在内）。键为子组名，值为子串。*默认*参数用于未参与匹配的组；它默认为`None`。

  ```python
  >>> m = re.match(r"(?P<first_name>\w+) (?P<last_name>\w+)", "Malcolm Reynolds")
  >>> m.groupdict()
  {'first_name': 'Malcolm', 'last_name': 'Reynolds'}
  ```

  ​

* `match.``start`([*group*])

  `match.``end`([*group*])

  返回由*group*匹配的子字符串的开头和结尾的索引； *组*默认为零（表示整个匹配的子字符串）。如果*组*存在，但没有对匹配作出贡献，则返回`-1`。对于匹配对象*m*和确实有助于匹配的组*g*，组*g*匹配的子串（等效于`m.group(g)`）

  ```python
  m.string[m.start(g):m.end(g)]
  ```

  ​

* `match.``span`([*group*])

  对于匹配*m*，返回2元组`（m.start（group）， m.end（group）） / t1>。`

  ​

* `match.``pos`

  传递到regex object的`search()`或`match()`方法的*pos*这是重新引擎开始寻找匹配的字符串中的索引。

* `match.``endpos`

  传递到regex object的`search()`或`match()`方法的*endpos*这是之外，重新引擎不会将字符串中的索引。

* `match.``lastindex`

  上一个匹配捕获组的整数索引，或`None`（如果没有匹配任何组）。

* `match.``lastgroup`

  上次匹配的捕获组的名称，或`None`如果组没有名称，或者没有匹配任何组。

* `match.re`

  `match()`或`search()`的正则表达式对象产生此匹配实例。

* `match.string`

  被`match()`或者`search()`匹配的字符串。

* ​



##四、search() vs. match()

Python提供了两种基于正则表达式的基本操作：

* `re.match()`仅在字符串开头检查匹配
* `re.search()`字符串全局搜索匹配

```python
>>> re.match("c", "abcdef")    # No match
>>> re.search("c", "abcdef")   # Match
<_sre.SRE_Match object; span=(2, 3), match='c'>
```

